<!-- d2697813-8f35-4199-8961-aadff4c52ae2 ad4e5e0d-39d6-4e1d-866a-9f8be497e332 -->
# Single-player Replay & Checksum v1

## Scope

- Implement local replays (single-player) recorded as JSONL with periodic checksum-tree state dumps. 
- Add Load Replay to Create Game menu (locks settings to replay’s meta). 
- Add Save Replay button in Pause menu. 
- Architect to extend for multiplayer later (host-only recording, per-player actions).

## Data format

- Replay file: `user://replays/<id>.jsonl`
  - Line 1 (meta):
    - `{ "type":"meta", "version":1, "created_at":<utc>, "seed":<int>, "settings": { "game_mode", "difficulty", "team_mode", "map_id", "wave_count" }, "checksum_period": <int>, "state_dir":"_state" }`
  - Timeslot lines:
    - `{ "type":"timeslot", "tick":<int>, "actions":[<Action.serialize() dicts incl. PLAYER_ID>], "root_checksum":"<sha256-hex>", "state_file":"<relative-path>" }` for snapshot ticks
    - `{ "type":"timeslot", "tick":<int>, "actions":[...] }` for non-snapshot ticks
- State dumps: `user://replays/_state/<id>-<tick>.json`
  - `{ "tick":<int>, "root":"<sha256-hex>", "towers":{...}, "creeps":{...}, "items":{...} }`
  - Entity keying: use runtime `uid` and also a stable fallback key (e.g., `tower:<type_id>@<grid_x>,<grid_y>`). Entity value contains invariant fields needed for checksum (hp, exp, mana, position, statuses, damage_dealt, etc.).

## New modules (colocated under `src/replay/`)

- `ReplayRecorder.gd`: lifecycle-owned by `GameHost`; captures timeslots on `_save_timeslot` and writes JSONL; requests periodic `StateSnapshotter` dumps and writes `root_checksum`/`state_file` into the line.
- `ReplayPlayer.gd`: owned by Title/CreateGame flow and `GameScene`; parses header, seeds `Globals`, injects recorded timeslots to `GameClient` each tick; locks input until EOF; then releases control.
- `StateSnapshotter.gd`: builds checksum-tree (and root SHA-256) from current scene state; adjustable frequency.
- `ReplayTypes.gd`: small constants/helpers (paths, schema version, loggable action allowlist).

## Integration points

- Record (host turn boundary):
```224:235:src/game_scene/game_host.gd
func _save_timeslot():
	var timeslot: Array = _in_progress_timeslot.duplicate()
	_in_progress_timeslot.clear()
	...
	timeslots_to_send[_current_tick] = timeslot
```

  - After constructing `timeslot`, call `ReplayRecorder.record(_current_tick, timeslot)` (single-player only, feature-flagged).
  - Filter actions to loggable state-changers (exclude non-state UI such as `SELECT_UNIT`, `SORT_ITEM_STASH`, `SET_PLAYER_NAME`).
- Playback (client tick consumption):
```226:234:src/game_scene/game_client.gd
for action in timeslot:
	_execute_action(action)
...
_update_state()
_current_tick += 1
```

  - Before `_do_tick()` pulls a needed timeslot, `ReplayPlayer` preloads next chunk via `receive_timeslots({...})` so the client proceeds uninterrupted.
- Determinism: seed at game start from meta.
```100:104:src/game_scene/game_scene.gd
Globals.synced_rng.set_seed(origin_seed)
print_verbose("Origin seed to: ", origin_seed)
```

- Game speed: no logging; speed only changes ticks-per-physics-tick, not tick delta; deterministic logic remains the same.
```209:213:src/game_scene/game_client.gd
var update_tick_count: int = min(Globals.get_update_ticks_per_physics_tick(), Constants.MAX_UPDATE_TICKS_PER_PHYSICS_TICK)
var should_tick: bool = ticks_during_this_process < update_tick_count
```


## UI

- Create Game: in `src/ui/title_screen/title_screen.gd/.tscn`
  - Add “Load Replay…” file picker. When a file is chosen:
    - Parse meta; prefill seed/settings; grey-out/disable other controls; show a small badge “Using replay settings”.
    - Start game in replay mode with that file.
- Pause menu: in `src/ui/game_menu/game_menu.gd/.tscn`
  - Add “Save Replay From Start” button; invokes `ReplayRecorder.save_current_to(file)` (single-player only).

## Checksum-tree

- Default `checksum_period`: 300 ticks (10s). Configurable via Settings and stored in meta.
- Entity hashing: JSON canonical string of selected fields then SHA-256; root hash as ordered hash over entity-subtrees.
- During playback, if a snapshot tick has `root_checksum` and the local recomputed root differs, warn to console + chat (no hard stop in v1).

## Multiplayer readiness

- All recording logic resides on host (`GameHost`) and records timeslots already fan-out to players. The file schema already includes `PLAYER_ID` inside actions. Future work: capture per-player names/ids in meta and host-only write path.

## Config/flags

- Settings:
  - `Settings.REPLAY_SNAPSHOT_PERIOD_TICKS` (default 300)
  - `Settings.REPLAY_ENABLED` (on by default for single-player)
- Respect [MINIMAL_CHANGE]: default-off UI elements hidden unless relevant.

## Out of scope now

- Compression, cloud/Nakama storage, mid-game resume from snapshot, deep mismatch auto-diff UX.

[USE_JUDGEMENT] Using a level-1 heading here because the planning tool requires it, despite our normal markdown preference.

### To-dos

- [ ] Create ReplayRecorder and write JSONL timeslots + meta
- [ ] Hook GameHost._save_timeslot to call ReplayRecorder.record
- [ ] Implement StateSnapshotter for periodic checksum-tree dumps
- [ ] Add Pause menu button to save replay to file
- [ ] Add Load Replay to Create Game and lock settings
- [ ] Implement ReplayPlayer to inject timeslots and lock input
- [ ] Seed Globals/settings from replay meta on start
- [ ] During playback, warn if snapshot root checksum differs